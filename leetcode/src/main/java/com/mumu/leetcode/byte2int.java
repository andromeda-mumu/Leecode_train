package com.mumu.leetcode;

/**
 * Created by wangjiao on 2020/8/7.
 * description:  byte与int互转问题
 * https://blog.csdn.net/luo4566/article/details/85219330?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-2
 */
public class byte2int {
    public static void main(String[] args) {
        /** 保持数值不变 */
        byte a = (byte)0xff;
        System.out.println(a);
        int i= a;
        System.out.println("i:"+i);

        /** 保持最低字节中各位不变，3个高字节全用0填充. 一般用于编解码操作 */
        int ii = a & 0xff;
        System.out.println("ii:"+ii);

    }
    /** 原码
     * +1原=0000 00001
     * -1原=1000 0001
     *
     *  反码
     * 正数的反码是本身，负数的反码是原码基础上符号位不变，其余各个位取反
     * -1反 =1111 1110
     *
     *  补码
     * 正数的补码是棋本身，负数的补码是在原码的基础上，符号位不变，其余各位取反，最后+1.(即在反码的基础上+1)
     *
     * 一部分int转byte
     * java采用补码存储整数int型为4字节，32位，byte为1字节8位
     * 所以byte[]数组中存储一个int类型肯定是4个1字节组成，即byte[4]才能存放一个int值
     * 就算int是0在计算中也是占用32位表示：0000 0000 0000 0000 0000 0000 0000 0000存入byte中即4个下标中均未0
     *
     * int直接存入byte数组中及原理：
     * int a= 1246
     * 二进制表示：
     * |--------高16位-----||-------低16位------|
     *  00000000 00000000   00000100 11011110
     *  | A    | |B     |   |C     | |D     |
     *  [0]       [1]       [2]       [3] 放入byte[]数组的原理，将这个二进制以8位为1个字节存入byte数组中从数组下标0开始存入
     *  最后byte[]数组存储为这样：
     *  byte[0]=00000000 补码后0000 0000 转十进制真实数值0
     *  byte[1]=00000000 补码后0000 0000 转十进制真实数值0
     *  byte[2]=00000100 补码后0000 0100 转十进制真实数值4
     *  byte[2]=11011110 补码后1010 0010 转十进制真实数值-34
     *
     *  转换过程中进行&运算就是高位舍去，通俗说，就是不需要的数据清0处理，下面逐个说明：
     *
     *  由于byte只有8位，int32位，所以需要移位，把前面的每8位一组移动到最后8位上面来进行计算，其他数值都不参与计算
     *  int a=1246
     *  byte[] b= new byte[4]
     *
     *
     *  第一步：
     *  b[0]=(byte)(a>>24 & 0xff);
     *  将00000000 00000000 00000100 11011110 A区域移动到D区域往右边移动24位，主要获取A区的值
     *                               00000000 00000000   00000100 11011110 形成这样的
     *  空白的数据被抹掉就是0表示，移动后超出D区域数据属于移除情况，也舍掉，最后形成如下：
     *   00000000 00000000 00000000 00000000
     *  最后做&运算，这里移动24位，右边的数据溢出，做不做这个计算都不影响，还是表示下：
     *  00000000 00000000 00000000 00000000
     *  00000000 00000000 00000000 11111111 &计算0xff的二进制
     *  --------------------------------------
     *  00000000 00000000 00000000 00000000 结果是0
     *
     *  第二步：
     *  byte[1]=(byte)(a>>16 & 0xff)
     *  将00000000 00000000 00000100 11011110 B区域移动到D区域往右边移动16位，主要获取B区的值
     *                     00000000 00000000   00000100 11011110 形成这样的
     *  空白的数据被抹掉就是0表示，移动后超出D区域数据属于移除情况，也舍掉，最后形成如下：
     *  00000000 00000000 00000000 00000000
     *  00000000 00000000 00000000 11111111 &计算0xff的二进制
     *  --------------------------------------
     *  00000000 00000000 00000000 00000000 结果是0
     *
     *  第三步：
     *  byte[2]=(byte)(a>>8 & 0xff)
     *  将00000000 00000000 00000100 11011110 C区域移动到D区域往右边移动8位，主要获取C区的值
     *            00000000 00000000  00000100 11011110 形成这样的
     *  空白的数据被抹掉就是0表示，移动后超出D区域数据属于移除情况，也舍掉，最后形成如下：
     *  00000000 00000000 00000000 00000100
     *  00000000 00000000 00000000 11111111 &计算0xff的二进制
     *  --------------------------------------
     *  00000000 00000000 00000000 00000100 结果是4
     *
     *  第四步：
     *  byte[3]=(byte)(a & 0xff)
     *  将00000000 00000000 00000100 11011110 由于D区在末尾8位，不需要移位。
     *  直接&计算，这里充分体现出&0xff计算就是清除其余不需要的数据，由于8位钱还有0100这么个数
     *  但是我们只需要后8位，所以 &0xff计算清除掉
     *
     *  00000000 00000000 00000100 11011110
     *  00000000 00000000 00000000 11111111 &计算0xff的二进制
     *  --------------------------------------
     *  00000000 00000000 00000000 11011110 结果转十进制是222.可见是有问题的，
     *  int->byte我们只需要拿出最后8位出来进行处理 11011110，
     *  如果排除符号位，那么十进制算出来是94，加上符号位，得到-94.这个数也不对
     *
     *  因为java采用补码存储整数
     *  所以需要对11011110这个负数进行补码运算，
     *  10100001 +1
     *  ------------
     *  10100010 去除符号位，转换成十进制：2^5+2^1=34,加上签名符号位，-34就是最终结果
     *
     *
     *

     *
     * */


    /**
     *  二部分byte转int
     *  对于一个单一的byte转int就是其本身，因为byte范围是-128~127，如果输入超过这个值，直接编译不通过。
     *  byte i=12;
     *  int c=(int)i;
     *  c=12;
     *
     *  继续上面的最终byye[]数组中的结果是
     *  byte[] b={0,0,4,-32};从下标0-4存的是int类型的高位到低位的顺序
     *  |-----高16位-----||------低16位--------|
     *  00000000 00000000 00000100 11011110
     *  |   0  ||   0    ||  4    ||  -34  |
     *  int到byte是向右移动，转换过来就是反其道行之
     *
     *  第一步：
     *  00000000 00000000 00000100 11011110
     *                             00000000 00000000 00000100 11011110 原来下标0的数被右移24位
     *  所以获取小标[0]<<24左移24位
     *  下标[0]=0转2进制
     *  00000000 00000000 00000000 00000000 左移24位后的2进制，因为0怎么移动都是0
     *  00000000 00000000 00000000 11111111 再进行&FF运算，为何要&FF后面比较直观，这里是0 ，就不讲了
     *  00000000 00000000 00000000 00000000 补码
     *  ---------
     *  结果0
     *
     *  第二步：
     *  00000000 00000000 00000100 11011110
     *                    00000000 00000000 00000100 11011110 原下标1的数被右移16位
     *  获取小标[1]<<16 左移16位
     *  下标[1]=0转二进制00000000
     *  00000000 00000000 00000000 00000000 左移16位后，二进制还是0，因为0怎么移动都是0
     *  00000000 00000000 00000000 11111111 再进行&FF运算，
     *  00000000 00000000 00000000 00000000 补码
     *  ----------
     *  结果0
     *
     *  第三部：
     *  00000000 00000000 00000100 11011110 原二进制
     *           00000000 00000000 00000100 11011110 原下标2的数被右移8位
     *
     *  获取下标[2]<<8 左移8位
     *  下标[2]=4 转二进制0000 0100
     *   00000000 00000000 00000100 00000000  左移8位后的二进制
     * & 00000000 00000000 00000000 11111111 进行&0xff运算
     *   -----------------------------------
     *   00000000 00000000 00000000 00000000  结果是0  ----------------------------------有问题----------------
     *
     *
     *  第四步：
     *  下标[3]=-34转二进制11111111 11111111 11111111 11011110
     *  11111111 11111111 11111111 11011110原来下标3的数就是末尾8位没有发送过移动，所以不需要移位
     *  00000000 00000000 00000000 11111111 这里比较直观&ff,计算去掉不需要的数据，可以称作 清0操作
     *  -----------------
     *  00000000 00000000 00000000 11011110 结果
     *  00000000 00000000 00000000 11011110 补码后
     *  这事11011110并不是负数，因为现在是byte转int，上面进行&FF运算后最高位是0，所以是正数。正数的补码就是本身。
     *  ----------------
     *  转十进制是222
     *
     *  所以最终4个结果相加0+0+1024+222=1246
     *
     *
     *
     * */
    public static void method(){

    }


}

